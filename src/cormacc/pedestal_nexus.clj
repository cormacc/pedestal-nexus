(ns cormacc.pedestal-nexus
  (:require [nexus.core :as nexus]))

;; See https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status
(def http-status-codes
  {:ok 200
   :created 201
   :accepted 202
   :not-found 404
   :internal-server-error 500})

(defn lookup-status-code [code] (or (some->> code (get http-status-codes)) (:internal-server-error http-status-codes)))

(def nexus-core
  {:nexus/effects
   {:http/response
    (fn [{:keys [dispatch-data] :as _ctx} _sys status body & {:as headers}]
      (let [status-code  (if (keyword? status)
                           (lookup-status-code status)
                           status)]
        (deliver (:response+ dispatch-data) (assoc dispatch-data :response
                                                   {:status status-code
                                                    :body body
                                                    :headers headers}))))}})

(defn- create-nexus-interceptor [nexus-app system]
  (let [nexus (merge-with merge nexus-core nexus-app)
        system-deref (:nexus/system->state nexus)]
    {:name :nexus-interceptor
     :enter
     (fn [context]
       (assoc context
              :state (system-deref system)
              :actions []))
     :leave
     (fn [{:keys [actions] :as context}]
       (let [response-promise (promise)
             ;;N.B. the context arg passed here is available as :dispatch-data within the nexus effect context map
             {:keys [errors]} (nexus/dispatch nexus system (assoc context :response+ response-promise) actions)
             ;;N.B. This will block indefinitely if there's no [[http-response ...]] effect generated by the handler
             ;;TODO: Bypass the wait when none of the returned actions is http-response.... use walk/postwalk?
             ;;      Pedestal returns a default response of OK when :response not set on context, so should allow
             ;;      this to pass through...
             ctx-new @response-promise]
         ;;TODO: Optionally pass in an error callback...
         (when-let [error (->> errors (keep :err) first)]
           (throw error))
         ctx-new))}))

(defn var-name=>keyword [the-var]
  (-> the-var meta :name keyword))

(defn- =>action-interceptor [action-generator]
  {:name (var-name=>keyword action-generator)
   :enter
   (fn [context]
     (assoc context :actions (action-generator context)))})

(defn create-nexus-wrapper [nexus system]
  (let [nexus-interceptor (create-nexus-interceptor nexus system)]
    (fn [action-generator]
      [nexus-interceptor (=>action-interceptor action-generator)])))
